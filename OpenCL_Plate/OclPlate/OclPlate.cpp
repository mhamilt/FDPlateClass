//
//  OclPlate.cpp
//  OpenCL_Plate
//
//  Created by mhamilt7 on 20/08/2019.
//  Copyright Â© 2019 mhamilt7. All rights reserved.
//

#include "OclPlate.hpp"
#include "fd_plate_kernel.cl.h"    // generated by Xcode on first build

OclPlate::OclPlate()
{
    //    setupCl();
}

OclPlate::~OclPlate()
{
    //--------------------------------------------------------------------------
    if (queue != nullptr) 
        dispatch_release(queue);
    //--------------------------------------------------------------------------
}

void OclPlate::setupCl()
{
    //--------------------------------------------------------------------------
    queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, NULL); // GPU in our system.
    
    if (queue == NULL)    // we can use the OpenCL CPU compute device instead.
    {
        queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_CPU, NULL);
    }
    //--------------------------------------------------------------------------
    printClDevice();
    //--------------------------------------------------------------------------
    // Generate buffers
    //    u, u1, u2, B, C, Ny
    std::cout << "Number of items: " << nextSquare(ss)<<'\n';
}


int OclPlate::nextSquare(int N)
{
    int v = N;
    
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++; // next power of 2
    
    return v;
}


void OclPlate::printClDevice()
{
    char name[128];
    cl_device_id gpu = gcl_get_device_id_with_dispatch_queue(queue);
    clGetDeviceInfo(gpu, CL_DEVICE_NAME, 128, name, NULL);
    printf("Created a dispatch queue using the %s\n", name);
}

void OclPlate::clupdate(float* out, int frames)
{
    
    //--------------------------------------------------------------------------
    // Coeffs
    cl_int* Ny_local;
    cl_int* ss_local;
    int dataSize = nextSquare(ss) * sizeof(cl_float);
    size_t clItems = nextSquare(ss);
    
    cl_float* u_local  = new cl_float[dataSize];
    std::fill(u_local, u_local+dataSize, 0);
    std::copy(u, u + ss, u_local);
    cl_float* u1_local = new cl_float[dataSize];
    std::fill(u1_local, u1_local+dataSize, 0);
    std::copy(u1, u1 + ss, u1_local);
    cl_float* u2_local = new cl_float[dataSize];
    std::fill(u2_local, u2_local+dataSize, 0);
    std::copy(u1, u1 + ss, u1_local);
    
    //--------------------------------------------------------------------------
    // Coeffs
    //    B_local = new cl_float[4];
    cl_float B_local[6] = {B00, B01,B02,B11,BC1,BC2};
    cl_float C_local[2] = {C00, C01};
    Ny_local = new cl_int(Ny);
    ss_local = new cl_int(ss);
    //--------------------------------------------------------------------------
    __block void* cl_u = gcl_malloc(dataSize, u_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    __block void* cl_u1 = gcl_malloc(dataSize, u1_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    __block void* cl_u2 = gcl_malloc(dataSize, u2_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    void* cl_B = gcl_malloc(6*sizeof(cl_float), B_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    void* cl_C = gcl_malloc(2*sizeof(cl_float), C_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    void* cl_Ny = gcl_malloc(sizeof(cl_int), &Ny, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    void* cl_Nx = gcl_malloc(sizeof(cl_int), &Nx, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    void* cl_ss = gcl_malloc(sizeof(cl_int), &ss, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    //--------------------------------------------------------------------------
    float* output = new float(0);
    void (^kernelBlock)() =
    ^{
        size_t wgs;
        gcl_get_kernel_block_workgroup_info(fd_plate_kernel,
                                            CL_KERNEL_WORK_GROUP_SIZE,
                                            sizeof(wgs),
                                            &wgs, NULL);
        cl_ndrange range =  // 6
        {
            1,                  // The number of dimensions to use.
            {0, 0, 0},          // Offset in each dimension.  To specify in the test case // 7
            {clItems,0, 0},    // global range: how many items IN TOTAL in each dimension to process.
            {32, 0, 0}        // Local size of each workgroup.
        };
        fd_plate_kernel(&range,
                        (cl_float*)cl_u,
                        (cl_float*)cl_u1,
                        (cl_float*)cl_u2,
                        (cl_float*)cl_B,
                        (cl_float*)cl_C,
                        (cl_int*)cl_Ny,
                        (cl_int*)cl_Nx,
                        (cl_int*)cl_ss);
        
        void* dummy = cl_u2; cl_u2 = cl_u1; cl_u1 = cl_u; cl_u = dummy; // swap pointers
        // very slow, currently only way to get output
//        gcl_memcpy(output, static_cast<cl_float*>(cl_u1)+lo, sizeof(cl_float));
    };
    //--------------------------------------------------------------------------
    for(int n = 0; n < frames; ++n)
    {
        dispatch_sync(queue, kernelBlock);
        out[n] = *output;
    }
    //--------------------------------------------------------------------------
    gcl_free(cl_u);
    gcl_free(cl_u1);
    gcl_free(cl_u2);
    gcl_free(cl_B);
    gcl_free(cl_C);
    gcl_free(cl_Ny);
    delete [] u_local;
    delete [] u1_local;
    delete [] u2_local;
    delete [] Ny_local;
    
}
