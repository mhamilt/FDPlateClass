//
//  OclPlate.cpp
//  OpenCL_Plate
//
//  Created by mhamilt7 on 20/08/2019.
//  Copyright Â© 2019 mhamilt7. All rights reserved.
//

#include "OclPlate.hpp"


#include "fd_plate_kernel.cl.h"    // generated by Xcode on first build
OclPlate::OclPlate()
{

}

OclPlate::~OclPlate()
{
    //--------------------------------------------------------------------------
    gcl_free(cl_u);
    gcl_free(cl_u1);
    gcl_free(cl_u2);
    gcl_free(cl_B);
    gcl_free(cl_C);
    gcl_free(cl_Ny);
    delete [] u_local;
    delete [] u1_local;
    delete [] u2_local;
    delete [] B_local;
    delete [] C_local;
    delete [] Ny_local;
    dispatch_release(queue); // Finally, release your queue just as you would any GCD queue.    // 11
    //--------------------------------------------------------------------------
}

void OclPlate::setupCl()
{
    //--------------------------------------------------------------------------
    queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, NULL); // GPU in our system.
    
    if (queue == NULL)    // we can use the OpenCL CPU compute device instead.
    {
        queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_CPU, NULL);
    }
    //--------------------------------------------------------------------------
    printClDevice();
    //--------------------------------------------------------------------------
    // Generate buffers
    //    u, u1, u2, B, C, Ny
    int dataSize = nextSquare(ss) * sizeof(cl_float);
    clItems = nextSquare(ss);
//    add extra points for making up to square
    u_local  = new cl_float[dataSize];
    std::copy(u, u + ss, u_local);
    std::fill(u_local, u_local+dataSize, 0);
    u1_local = new cl_float[dataSize];
    std::copy(u1, u1 + ss, u1_local);
    std::fill(u1_local, u1_local+dataSize, 0);
    u2_local = new cl_float[dataSize];
    std::copy(u1, u1 + ss, u1_local);
    std::fill(u2_local, u2_local+dataSize, 0);

    //--------------------------------------------------------------------------
    // Coeffs
    B_local = new cl_float[4];
    C_local = new cl_float[2];
    Ny_local = new cl_int(Ny);
    ss_local = new cl_int(ss);
    //--------------------------------------------------------------------------
    cl_u = gcl_malloc(dataSize, u_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    cl_u1 = gcl_malloc(dataSize, u1_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    cl_u2 = gcl_malloc(dataSize, u2_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    cl_B = gcl_malloc(4*sizeof(cl_float), B_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    cl_C = gcl_malloc(2*sizeof(cl_float), C_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    cl_Ny = gcl_malloc(sizeof(cl_int), Ny_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    cl_ss = gcl_malloc(sizeof(cl_int), ss_local, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    //--------------------------------------------------------------------------
}


int OclPlate::nextSquare(int N)
{
    int nextN = floor(sqrt(N)) + 1;
    return nextN * nextN;
}

void OclPlate::printClDevice()
{
    char name[128];
    cl_device_id gpu = gcl_get_device_id_with_dispatch_queue(queue);
    clGetDeviceInfo(gpu, CL_DEVICE_NAME, 128, name, NULL);
    printf("Created a dispatch queue using the %s\n", name);
}

float OclPlate::clupdate()
{
    float *output = new float(0);
    //--------------------------------------------------------------------------
    // Apple Code Block: Basically a lambda function
    void(^kernelBlock)() =
    ^{
        size_t wgs;
        gcl_get_kernel_block_workgroup_info(fd_plate_kernel, CL_KERNEL_WORK_GROUP_SIZE, sizeof(wgs), &wgs, NULL);
        cl_ndrange range =  // 6
        {
            1,                  // The number of dimensions to use.
            {0, 0, 0},          // Offset in each dimension.  To specify in the test case // 7
            {clItems, 0, 0}, // global range: how many items IN TOTAL in each dimension to process.
            {wgs, 0, 0}         // Local size of each workgroup.
        };
        fd_plate_kernel(&range,
                        (cl_float*)cl_u,
                        (cl_float*)cl_u1,
                        (cl_float*)cl_u2,
                        (cl_float*)cl_B,
                        (cl_float*)cl_C,
                        (cl_int*)cl_Ny,
                        (cl_int*)cl_ss);
        // cl pointer swap
        void* dummy = cl_u2; cl_u2 = cl_u1; cl_u1 = cl_u; cl_u = dummy; // swap pointers
        gcl_memcpy(output, static_cast<float*>(cl_u1)+lo, sizeof(cl_float));
    };
    
    dispatch_sync(queue, kernelBlock);
    //--------------------------------------------------------------------------
    float val = *output;
    delete output;
    return val;
}
